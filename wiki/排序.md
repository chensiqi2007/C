# 冒泡排序



## 代碼


# 选择排序
在每一轮排序中，我们从未排序区域找出最小的元素，将它放到未排序区域的最前面。通过不断重复这个过程，整个数组最终会变成有序的。

## 代碼
<br>

     #include <stdio.h>
    #include <stdlib.h>
    #define N 10

    int main(void) {
    (void)system("chcp 65001 ");
    int a[N] , i=0 , j=0;
    // 獲取數據
    for (i=0 ; i<N ; i++) {
        (void)printf("请输入第%d个数：",i+1);
        (void)scanf("%d",&a[i]);
    }
    // 編列確認輸入的數組
    for (i=0 ; i<N ; i++){
        (void)printf("您輸入的數組是：%-5d \n",a[i]);
    }
    // 選擇排序
    for (i=0 ; i<N-1 ; i++) {
        int temp , index = i;
        for (j ; j<N-1-i ; j++) {
            if (a[index]>a[j]) {
                index = j;
            }
        }
        // 优化：将交换操作提取到单独的代码块中，提高可读性
        if (index != i) {
            int temp = a[i];
            a[i] = a[index];
            a[index] = temp;
        }
        // 输出当前排序步骤的结果
        (void)printf("選擇排序的第%d個數：%-5d\n",i+1,a[i]);
        }
    }

# 使用函數的選擇排序

## 代碼

     #include <stdio.h>
     #include <stdlib.h>
     #define N 10

     void getElements(int a[], int len) {
    int i;
    for (i=0; i<len; i++) {
        printf("Please input the %dth element:", i+1);
        scanf("%d", &a[i]);
    }
     }

      void displayArray(int a[], int len) {
    int i;
    for (i=0; i<len; i++) {
        printf("%-5d ", a[i]);
    }
     }

     void selectSort(int a[],int len) {
    int i,j;
    for (i=0; i<len-1; i++) {
        int index = i;
        for (j=i+1; j<len; j++) {
            if (a[j] < a[index]) {
                index = j;
            }
        }
        if (index != i) {
            int temp = a[i];
            a[i] = a[index];
            a[index] = temp;
        }
    }
     }
     

     int main(void) {
         (void)system("chcp 65001 ");
         int a[N];

    getElements(a,N);
    displayArray(a,N);
    selectSort(a,N);
    printf("\n=======================\n");
    displayArray(a,N);
    return 0;
    }
